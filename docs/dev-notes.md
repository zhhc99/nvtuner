# 对开发者

## 关于开发动机

我在构建自己的 SFF 系统时遇到了散热问题. 单独设置功耗墙会大大降低性能. 我想到, 我只需对 GPU 略微超频, 就可以在尽可能保持频率的同时把功耗降低下来, 以满足我的散热条件.

我不太喜欢 Afterburner 过时的 UI 和繁杂的组件, 同时我也不想后台时刻挂着 HWiNFO64 (来调查性能下降的原因). 因此我用 `Electron` + `React` + `C++` 实现了一个软件. 它有现代化的 UI, 通过 C++ 后端与 GPU 通信, 可以展示 GPU 的各种状态, 记录图表, 设置超频参数并开机自动应用.

那个东西还挺好看的, 但我始终觉得有些奇怪. 不知道为什么, 我在某一天注意到了命令行 UI. 我意识到, 我心中想要的东西应该非常精简, 高效, 易用. 这就是 NVTuner (在我心中期望的样子).

## 设计与技术备忘

- **Clock Offset Step**: 不同架构显卡的核心频率步进值可能不同 (如 12.5MHz) , 而非固定的 15MHz. 目前 UI 上的 15MHz 步进不影响实际设置, 因为 GPU 会自动对齐到有效值.
- **Curve Offset 范围**: 曾考虑过硬编码一个较小的 CO 范围 (如 +/-180MHz) 来防止用户误操作. 但考虑到不同显卡的参数差异较大, 最终决定提供 NVML API 允许的完整范围. 应该通过 **超频手册** 引导用户安全操作.
- **功耗读取**: 部分显卡不支持 `nvmlDeviceGetPowerUsage`. 已切换到 `sample` 接口作为备选, 其读数与 AIDA64 一致, 暂定为可接受方案. 另外, 旧驱动下无法获取 Power Cap, 可能是接口问题.
- 热点温度传感器自 50 系似乎被 Nvidia 移除了, 不要试图读取它.
- 40+ 系的 Laptop GPU 似乎有驱动 / 硬件上的功耗控制, 需要用 `nvmlDeviceGetEnforcedPowerLimit` 读取其当前实际功耗墙. 该数值会随系统状况而变化. 对应的功耗墙 Constraints 和 Default 接口仍然返回 SUCCESS, 但是数值并没有太大意义, 对其的修改也无效. 如果 `nvmlDeviceGetPowerManagementLimit` 为 UNSUPPORTED, 似乎就对应这类 GPU.

## 近期计划 (Roadmap / TODO)

- [x] **文档: 简易超频手册**
  - 降压超频的好处.
  - 使用本软件进行超频的方法和注意事项.
  - 紧急恢复指南: 指导用户在因设置错误 (特别是开机自启超频) 导致开机花屏/崩溃时, 如何进入安全模式或用命令行工具重置配置.
- [ ] **监控图表**
  - 创建一个新 Tab, 用于实时监控过去 5 分钟内各显卡的 `utilization` 和 `power` 曲线.
  - 图表已经以 2 种样式创建, 但我对功能并不满意. 后续将关注对用户调教有帮助的功能, 如按需监控一段时间的 max / avg / min 等关键参数.
- [x] **Linux 支持的验证**
  - 用 Colab (Tesla T4) 完成了编译并处理了一些较旧驱动导致的问题.
  - 在 Fedora 42 通过测试 (配置文件的读写和应用, systemd 服务的构建与自动卸载等).
  - 通过文档提示用户处理驱动的 Persistence Mode. 现代 Linux 发行版一般能够在安装 NVIDIA 驱动时安装 `nvidia-persistenced` systemd 服务 (但未必启用).
  - 如果一些较旧的发行版没有安装 `nvidia-persistenced`, 则应给用户指引, 或在开机 apply profile 时执行 `nvmlDeviceSetPersistenceMode` 切换到持久模式 (并提醒这可能额外造成资源消耗).
- [ ] **路径中含 CJK 字符 / 空格时的鲁棒性验证**
  - 代码尽可能处理了这些情况, 但尚未做完整测试.

## 未计划的功能

- **显存超频**
  - NVML 存在显存超频的接口. 然而, 对于近些年的显卡, 显存超频带来的收益有限, 且需要更多调教和测试.
  - 引入显存超频可能给用户增添复杂度, 这违背了开发的初衷 (帮助更多人轻松调教显卡).
- **AMD 显卡支持**
  - 相较 NVML, AMD 的工具 ADL / ADLX 不支持 Linux 系统, 这对跨平台开发带来障碍.
  - AMD 和 NVIDIA 显卡在超频方面的配置项似乎也不太一致.
